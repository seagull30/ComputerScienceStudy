 7장 데이터 구조와 처리
===
### 객체 지향의 함정
- 객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어있다.
- 모든 데이터와 함수가 들어있기 때문에 메소드가 많으면 구조체가 커질수 있지만 메소드를 별도의 데이터 구조에 담아 해결할수 있다.
- 하지만 객체와 관련된 부가 비용이 존재하기 때문에 성능이 결정적으로 중요할때는 전통적인 배열을 활용하는 것이 좋다.
### 정렬
- 정렬을 하는 이유
  - 데이터를 정렬해서 저장하면 메모리 접근 횟수를 줄임으로써 검색을 빨리 끝낼수 있다.
-  qsort : 퀵정렬 알고리즘을 구현한 라이브러리 함수
   - 데이터를 정렬하는 방법을 알고 있지만 데이터를 비교한는 방법은 알지 못하기 때문에 함수 포인터를 사용한다.
   - 두 원소 a와 b가 있을때 두 값을 비교한 값을 돌려주는 함수를 가리키는 포인터를 함꼐 전달한다.
### 해시
- 해싱 : 키값을 해시 함수라는 수식에 대입시켜 계산한 후 나온 결과를 주소로 사용하여 바로 값에 접근하게 할 수 있는 방법
  - 하지만 해시 함숫값의 범위가 너무 크면 데이터를 너무 많이 사용하거나, 데이터가 너무 여기저기 흩어져서 메모리 접근 성능이 떨어질수있다. 
- 해시 테이블 : 해시 함수의 결과를 배열 인덱스(버킷)로 만든 것. 
- 충돌 : 서로 다른 두 개의 입력값에 대해 동일한 출력값을 내는 상황
  - 분리 연결법 : 여러 데이터가 동일한 버킷으로 접근을 한다면 추가 메모리를 사용하여 다음 데이터의 주소를 저장하여 데이터들을 연결을 해서 관리 하는 방법. 데이터가 많아지면 그에 따라 캐시효율성이 감소한다.
  - 개방 주소법 : 비어있는 해시 테이블의 공간을 활용하는 방법이다.
    > 1. Linear Probing: 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대검색해 비어 있는 버킷에 데이터를 저장한다.
    > 2. Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하2^2, 3^2 칸씩 옮기는 방식이다.
    > 3. Double Hashing Probing: 해시된 값을 한번 더 해싱하여 해시의 규칙성없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문다른 방법들보다 많은 연산을 하게 된다. 
- 완전 해시 : 각 키를 유일한 버킷에 연결해 주는 방식으로 모든 키를 미리 알고 있지 않다면 완전한 해시 함수를 만들기는 거의 불가능하다.
### 효율성과 성능
- 샤딩 : 수평 파티셔닝이라 부르며 인터페이스를 통한 요청을 모든 샤드에 전달하고 컨트롤러가 결과를 하나로 모으는 방법으로 작업을 여러 작업자로 나눠 수행함으로써 성능이 향상된다.
- 맵리듀스 : 샤딩의 변종으로 근본적으로 콘트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있게 해준다.